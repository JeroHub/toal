---
title: "Comparison of localization methods"
author: "James Campbell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

`toal` holds a few different functions for localizing your acoustic tag data.
This vignette will demonstrate the differences between these methods.
For the sake of comparison, we

## YAPS

YAPS (Yet Another Positioning System) was proposed by Baktoft et al. (2017) and estimates positions from tag pulses by random walk models.
This results in much more robust localization methods as compared to those which are based on traditional localization methods based soled on differences in times of arrival as compared to areference hydrophone.
We've adapted the proposed YAPS models for different situations, with a particular focus on mesocosm experiments where an acoustically tagged fish is being tracked via a three-dimentional hydrophone array in a restricted swimming area.

Some key differences between Baktoft's YAPS and the flavors of YAPS presented here is that we:

- Assume a constant speed of sound throughout the sample period.
- Assume hydrophones have errors due to guassian random movement in three-dimentions.
- Assume a 0 centered guassian distribution of inter-pulse-intervals
- Works only on 3D positioning (as opposed to only on 2D).

While the extra assumptions of the YAPS model helps with position estimate robustness, if these assumptions are not clearly met there is a risk of misleading results.
Here we'll walk through some examples testing our YAPS flavors on "simulated data".
The "simulated data" presented here consists of datasets of estimated fish positions from previous experiments.
These positions have been cleaned and we will treat these as the true positions of the simulated fishs we are working with.
Finally, we can simulate sources of error on top of our "true fish" positions.
These sources of error include:

- Guassian movement of reciever hydrophones, as assumed to be a result of wave action.
- Sample rate limitations be reciever setup

### YAPS Continual Swimming

This flavor of YAPS is based on the following assumptions:

- Swimming speed between tag pulses follows a Guassian distribution (i.e. no stationary resting periods)
- Speed of sound through water is a constant value
- Hydrophone array arranged for 3D positioning (all hydrophone not positioned along a single plane)

To test this out we'll use some previously collected data on sea bass.

```{r} 
require(toal)
require(ggplot2)
## Load seabass data (continual swimming)
data("Pen_SeaBass")

## Speed of sound (with simualted error)
c <- 1500
## Add some error to c
c.real <- rnorm(n = 1, mean = 1500,sd = 1)

## Get track time-or-arrival values for first fish
fish.ids <- unique(Pen_SeaBass[[1]]$Period)
xyz.true <- subset(Pen_SeaBass[[1]], Period == fish.ids[1])[1:200,c(3:5,1)]

toa.expected <- xyz2toa(hydrophone.positions = Pen_SeaBass[[2]][,2:4], 
               tag.positions = xyz.true,
               c = c.real)

## Simulate soruces of error
hydrophoneMovement.sd <- 0.05
pingDetection <- 0.95
ggplot(data = data.frame(ms = rnorm(n = 10000,mean = 0, sd = hydrophoneMovement.sd)*100)) + 
  geom_histogram(aes(x = ms)) + ggtitle('Simulated Hydrophone movement (along direction of sound propagation)') +
  xlab('Centimeters') + theme_bw()

toa.real <- toaSimError(toa = toa.expected, reciever.fs = 12000,
                        hydrophoneMovement.sd = hydrophoneMovement.sd,
                        p.detect = pingDetection, c = c.real)

# Plot differences between expected and real toa
ggplot(data = rbind(H1 = matrix(toa.real[,1] - toa.expected[,1], ncol = 1),
                    H1 = matrix(toa.real[,2] - toa.expected[,2], ncol = 1),
                    H1 = matrix(toa.real[,3] - toa.expected[,3], ncol = 1),
                    H1 = matrix(toa.real[,4] - toa.expected[,4], ncol = 1)))

for(i in 1:4){
  hist(()*1000, main = paste0('Latency Error/Detection: H',i),
       xlab = 'Milliseconds', col = 'grey')
}
par(mfrow = c(1,1))

hist(apply(X = toa.real, MARGIN = 1,
           FUN = function(x){
             length(which(!is.na(x)))
             }),breaks = c(0:4),
     col = 'grey', main = 'Hydrophone Detections/Ping',xlab = '# Hydrophones')

### Testing ###
hydrophone.pos <- Pen_SeaBass$hydrophones[,2:4]
toa <- toa.real
```

Now we have our dataset, we'll apply YAPS and compare its results to that of spherical interpolation.
To make sure things don't take too long, we'll restrict YAPS to 2000 iterations.
We'll also try one with 5000 to see if that gives a noticable improvement.
More iterations should result in potentially more accurate results.
We'll also time how long each method takes.

```{r}
require(tictoc)
## Spherical interopolation
tic();estimates.si <- TOA.localization(toa = toa.real,
                                 hydrohpone.positions = Pen_SeaBass[[2]][,2:4],
                                 c = c); toc()
```

We'll mute the output from this code block...

```{r,results=F, message=F, warning=F}
## YAPS-Pelagic
tic(); estimates.yaps.p.2000 <- yaps.pelagic(toa = toa.real, 
                                 hydrophone.pos = Pen_SeaBass[[2]][,2:4],
                                 c = c, max.iterations = 5000); toc()

```

Now we'll plot the results and compare the Shperical interpolation, which is a more conventional solution to localization, to YAPS.

```{r}
require(ggplot2)
require(magrittr)

## Append positional data
results <- rbind(as.matrix(estimates.si[estimates.si$eq == '-',2:4]),
                 as.matrix(estimates.si[estimates.si$eq == '+',2:4]),
                 as.matrix(estimates.yaps.p.2000[,1:3]),
                 as.matrix(xyz.true[,1:3])) %>% 
  as.data.frame()

## Append model identifiers
results$Model <- c(rep('SI-', times = dim(estimates.si[estimates.si$eq == '-',])[1]),
                   rep('SI+', dim(estimates.si[estimates.si$eq == '+',])[1]),
                   rep('YAPS.p.2000', times = dim(estimates.yaps.p.2000)[1]),
                   rep('True', times = dim(xyz.true)[1]))

row.names(results) <- NULL
head(results)

lt <- 0.5
ggplot(data = results) + 
  geom_path(aes(x = x, y = y, color = Model, size = Model,
                linetype = Model, col = Model)) +
  coord_equal(xlim = range(xyz.true$PosX),
                  ylim = range(xyz.true$PosY)) +
  theme_bw() + 
  scale_size_manual(values = c('SI-' = lt,
                              'SI+' = lt,
                              'True' = lt*2,
                              'YAPS.p.2000' = lt)) +
  scale_linetype_manual(values = c('SI-' = 1,
                              'SI+' = 1,
                              'True' = 2,
                              'YAPS.p.2000' = 1)) +
  scale_color_manual(values = c('SI-' = 'red',
                              'SI+' = 'red',
                              'True' = 'green',
                              'YAPS.p.2000' = 'blue')) +
  ggtitle('Horizontal Plane')

ggplot(data = subset(results, subset = Model != 'SI-')) + 
  geom_path(aes(x = y, y = z, color = Model, size = Model,
                linetype = Model, col = Model)) +
  coord_equal(xlim = range(xyz.true$PosY),
                  ylim = range(xyz.true$PosZ)) +
  theme_bw()  +
  scale_size_manual(values = c('SI-' = lt,
                              'SI+' = lt,
                              'True' = lt*2,
                              'YAPS.p.2000' = lt)) +
  scale_linetype_manual(values = c('SI-' = 1,
                              'SI+' = 1,
                              'True' = 2,
                              'YAPS.p.2000' = 1)) +
  scale_color_manual(values = c('SI-' = 'red',
                              'SI+' = 'red',
                              'True' = 'green',
                              'YAPS.p.2000' = 'blue')) +
  ggtitle('Vertical Plane')


message('YAPS estimate c: ', attr(estimates.yaps.p.2000, 'c'),', real c: ', c.real)
```

YAPS seems to do a good job of filling in the missing detections (when less than 4 hydrophones recieve a signal).

Finally, lets look at the distribution of our error terms, hydrophone latency.

```{r}
par(mfrow=c(2,2))
for(i in 1:4){
  hist((estimates.yaps.p.2000[,4+i])*1000, 
       main = paste0('Latency Error/Detection Estimated, H',i),
       xlab = 'Milliseconds', col = 'grey', breaks = 10)
}
par(mfrow=c(1,1))

hist(diff(estimates.yaps.p.2000[,4]), 
       main = paste0('Latency Error/Detection Estimated, H',i),
       xlab = 'Milliseconds', col = 'grey', breaks = 10)

```

The hydrophone latency is an issue here.
Typically, 1 hydrophone collects all the latency error, which the remaining three have smaller than expected variance.
I tried assuming all the hydrophones had the same SD of latency errors, but this caused very poor position estimates.

## References

Baktoft, H. Gjelland, K., Ã˜kland, F., Thygesen, U.  2017. **Positioning of aquatic animals based on time-of-arrival and random walk models using YAPS (Yet Another Positioning Solver)**. *Scientific Reports*. 7:17294.
